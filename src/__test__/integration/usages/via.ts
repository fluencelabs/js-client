/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/.
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.3.0-226
 *
 */
import { Fluence, FluencePeer } from '../../../index';
import {
    extractFunctionArgs,
    CallParams,
    ResultCodes,
    registerParticleSpecificHandler,
    handleTimeout,
    extractServiceArgs,
    registerHandler,
} from '../../../internal/compilerSupport/v2';
import { Particle } from '../../../internal/particle';

// Services

export interface CustomIdDef {
    id: (s: string, callParams: CallParams<'s'>) => string;
}

export function registerCustomId(service: CustomIdDef): void;
export function registerCustomId(serviceId: string, service: CustomIdDef): void;
export function registerCustomId(peer: FluencePeer, service: CustomIdDef): void;
export function registerCustomId(peer: FluencePeer, serviceId: string, service: CustomIdDef): void;
export function registerCustomId(...args1: any) {
    const { peer, serviceId, service } = extractServiceArgs(args1);

    registerHandler(peer, serviceId, 'id', (args, callParams) => {
        return service.id(args[0], callParams);
    });

    peer.internals.callServiceHandler.use(async (req, resp, next) => {
        if (req.serviceId !== serviceId) {
            await next();
            return;
        }

        if (req.fnName === 'id') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    s: req.tetraplets[0],
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.id(req.args[0], callParams);
        }

        await next();
    });
}

// Functions

export function viaArr(
    node_id: string,
    viaAr: string[],
    config?: { ttl?: number },
): Promise<{ external_addresses: string[] }>;
export function viaArr(
    peer: FluencePeer,
    node_id: string,
    viaAr: string[],
    config?: { ttl?: number },
): Promise<{ external_addresses: string[] }>;
export function viaArr(...args1: any) {
    const { peer, config, args } = extractFunctionArgs(args1, 2);

    return new Promise<{ external_addresses: string[] }>((resolve, reject) => {
        const script = `
      (xor
  (seq
   (seq
    (seq
     (seq
      (seq
       (seq
        (seq
         (seq
          (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
          (call %init_peer_id% ("getDataSrv" "node_id") [] node_id)
         )
         (call %init_peer_id% ("getDataSrv" "viaAr") [] viaAr)
        )
        (call -relay- ("op" "noop") [])
       )
       (fold viaAr -via-peer-
        (seq
         (call -via-peer- ("op" "noop") [])
         (next -via-peer-)
        )
       )
      )
      (xor
       (call node_id ("peer" "identify") [] p)
       (seq
        (seq
         (seq
          (fold viaAr -via-peer-
           (seq
            (call -via-peer- ("op" "noop") [])
            (next -via-peer-)
           )
          )
          (call -relay- ("op" "noop") [])
         )
         (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
        )
        (call -relay- ("op" "noop") [])
       )
      )
     )
     (fold viaAr -via-peer-
      (seq
       (call -via-peer- ("op" "noop") [])
       (next -via-peer-)
      )
     )
    )
    (call -relay- ("op" "noop") [])
   )
   (xor
    (call %init_peer_id% ("callbackSrv" "response") [p])
    (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
   )
  )
  (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
 )`;
        const particle = Particle.createNew(script, config?.ttl);

        registerParticleSpecificHandler(peer, particle.id, 'getDataSrv', '-relay-', () => {
            return peer.getStatus().relayPeerId;
        });

        registerParticleSpecificHandler(peer, particle.id, 'getDataSrv', 'node_id', () => {
            return args[0];
        });

        registerParticleSpecificHandler(peer, particle.id, 'getDataSrv', 'viaAr', () => {
            return args[1];
        });

        registerParticleSpecificHandler(peer, particle.id, 'callbackSrv', 'response', (args) => {
            const [res] = args;
            setTimeout(() => {
                resolve(res);
            }, 0);
            return {};
        });

        registerParticleSpecificHandler(peer, particle.id, 'errorHandlingSrv', 'error', (args) => {
            const [err] = args;
            setTimeout(() => {
                reject(err);
            }, 0);
            return {};
        });

        handleTimeout(peer, particle.id, () => {
            reject('Request timed out for viaArr');
        });

        peer.internals.initiateFlow(particle);
    });
}

/*
export function viaStream(
    node_id: string,
    viaStr: string[],
    config?: { ttl?: number },
): Promise<{ external_addresses: string[] }>;
export function viaStream(
    peer: FluencePeer,
    node_id: string,
    viaStr: string[],
    config?: { ttl?: number },
): Promise<{ external_addresses: string[] }>;
export function viaStream(...args: any) {
    let peer: FluencePeer;
    let node_id: any;
    let viaStr: any;
    let config: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
        node_id = args[1];
        viaStr = args[2];
        config = args[3];
    } else {
        peer = Fluence.getPeer();
        node_id = args[0];
        viaStr = args[1];
        config = args[2];
    }

    let request: RequestFlow;
    const promise = new Promise<{ external_addresses: string[] }>((resolve, reject) => {
        const r = new RequestFlowBuilder()
            .disableInjections()
            .withRawScript(
                `
      (xor
  (seq
   (seq
    (seq
     (seq
      (seq
       (seq
        (seq
         (seq
          (seq
           (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
           (call %init_peer_id% ("getDataSrv" "node_id") [] node_id)
          )
          (call %init_peer_id% ("getDataSrv" "viaStr") [] viaStr-iter)
         )
         (fold viaStr-iter viaStr-item
          (seq
           (ap viaStr-item $viaStr)
           (next viaStr-item)
          )
         )
        )
        (call -relay- ("op" "noop") [])
       )
       (fold $viaStr -via-peer-
        (seq
         (call -via-peer- ("op" "noop") [])
         (next -via-peer-)
        )
       )
      )
      (xor
       (call node_id ("peer" "identify") [] p)
       (seq
        (seq
         (seq
          (fold $viaStr -via-peer-
           (seq
            (call -via-peer- ("op" "noop") [])
            (next -via-peer-)
           )
          )
          (call -relay- ("op" "noop") [])
         )
         (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
        )
        (call -relay- ("op" "noop") [])
       )
      )
     )
     (fold $viaStr -via-peer-
      (seq
       (call -via-peer- ("op" "noop") [])
       (next -via-peer-)
      )
     )
    )
    (call -relay- ("op" "noop") [])
   )
   (xor
    (call %init_peer_id% ("callbackSrv" "response") [p])
    (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
   )
  )
  (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
 )
 
                  `,
            )
            .configHandler((h) => {
                h.on('getDataSrv', '-relay-', () => {
                    return peer.getStatus().relayPeerId;
                });
                h.on('getDataSrv', 'node_id', () => {
                    return node_id;
                });
                h.on('getDataSrv', 'viaStr', () => {
                    return viaStr;
                });
                h.onEvent('callbackSrv', 'response', (args) => {
                    const [res] = args;
                    resolve(res);
                });

                h.onEvent('errorHandlingSrv', 'error', (args) => {
                    const [err] = args;
                    reject(err);
                });
            })
            .handleScriptError(reject)
            .handleTimeout(() => {
                reject('Request timed out for viaStream');
            });
        if (config && config.ttl) {
            r.withTTL(config.ttl);
        }
        request = r.build();
    });
    peer.internals.initiateFlow(request!);
    return promise;
}

export function viaOpt(
    relay: string,
    node_id: string,
    viaOpt: string | null,
    config?: { ttl?: number },
): Promise<{ external_addresses: string[] }>;
export function viaOpt(
    peer: FluencePeer,
    relay: string,
    node_id: string,
    viaOpt: string | null,
    config?: { ttl?: number },
): Promise<{ external_addresses: string[] }>;
export function viaOpt(...args: any) {
    let peer: FluencePeer;
    let relay: any;
    let node_id: any;
    let viaOpt: any;
    let config: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
        relay = args[1];
        node_id = args[2];
        viaOpt = args[3];
        config = args[4];
    } else {
        peer = Fluence.getPeer();
        relay = args[0];
        node_id = args[1];
        viaOpt = args[2];
        config = args[3];
    }

    let request: RequestFlow;
    const promise = new Promise<{ external_addresses: string[] }>((resolve, reject) => {
        const r = new RequestFlowBuilder()
            .disableInjections()
            .withRawScript(
                `
      (xor
  (seq
   (seq
    (seq
     (seq
      (seq
       (seq
        (seq
         (seq
          (seq
           (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
           (call %init_peer_id% ("getDataSrv" "relay") [] relay)
          )
          (call %init_peer_id% ("getDataSrv" "node_id") [] node_id)
         )
         (call %init_peer_id% ("getDataSrv" "viaOpt") [] viaOpt)
        )
        (call -relay- ("op" "noop") [])
       )
       (fold viaOpt -via-peer-
        (seq
         (call -via-peer- ("op" "noop") [])
         (next -via-peer-)
        )
       )
      )
      (xor
       (call node_id ("peer" "identify") [] p)
       (seq
        (seq
         (seq
          (fold viaOpt -via-peer-
           (seq
            (call -via-peer- ("op" "noop") [])
            (next -via-peer-)
           )
          )
          (call -relay- ("op" "noop") [])
         )
         (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
        )
        (call -relay- ("op" "noop") [])
       )
      )
     )
     (fold viaOpt -via-peer-
      (seq
       (call -via-peer- ("op" "noop") [])
       (next -via-peer-)
      )
     )
    )
    (call -relay- ("op" "noop") [])
   )
   (xor
    (call %init_peer_id% ("callbackSrv" "response") [p])
    (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
   )
  )
  (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
 )
 
                  `,
            )
            .configHandler((h) => {
                h.on('getDataSrv', '-relay-', () => {
                    return peer.getStatus().relayPeerId;
                });
                h.on('getDataSrv', 'relay', () => {
                    return relay;
                });
                h.on('getDataSrv', 'node_id', () => {
                    return node_id;
                });
                h.on('getDataSrv', 'viaOpt', () => {
                    return viaOpt === null ? [] : [viaOpt];
                });
                h.onEvent('callbackSrv', 'response', (args) => {
                    const [res] = args;
                    resolve(res);
                });

                h.onEvent('errorHandlingSrv', 'error', (args) => {
                    const [err] = args;
                    reject(err);
                });
            })
            .handleScriptError(reject)
            .handleTimeout(() => {
                reject('Request timed out for viaOpt');
            });
        if (config && config.ttl) {
            r.withTTL(config.ttl);
        }
        request = r.build();
    });
    peer.internals.initiateFlow(request!);
    return promise;
}
*/
