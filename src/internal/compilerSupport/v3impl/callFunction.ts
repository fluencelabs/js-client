import { CallServiceData, CallServiceResult, ResultCodes } from '../../commonTypes';
import { FnConfig, FunctionCallDef } from './interface';
import { FluencePeer } from '../../FluencePeer';
import { Fluence } from '../../../index';
import { Particle } from '../../Particle';
import { aquaArgs2Ts, returnType2Aqua, ts2aqua } from './convert';

/**
 * Convenience function to support Aqua `func` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 *
 * @param rawFnArgs - raw arguments passed by user to the generated function
 * @param def - function definition generated by the Aqua compiler
 * @param script - air script with function execution logic generated by the Aqua compiler
 */
export function callFunction(rawFnArgs: Array<any>, def: FunctionCallDef, script: string) {
    if (def.arrow.domain.tag !== 'labeledProduct') {
        throw new Error('Should be impossible');
    }

    const argDefs = def.arrow.domain.fields;
    const argsDefLength = argDefs.length;
    const { args, peer, config } = extractFunctionArgs(rawFnArgs, argsDefLength);

    if (args.length !== argsDefLength) {
        throw new Error('Incorrect number of arguments. Expecting ${def.argDefs.length}');
    }

    const promise = new Promise((resolve, reject) => {
        const particle = Particle.createNew(script, config?.ttl);

        for (let i = 0; i < argsDefLength; i++) {
            const [argDefName, argDefType] = argDefs[i];
            const arg = args[i];

            let serviceId;
            let fnName = argDefName;
            let cb;
            if (argDefType.tag === 'arrow') {
                cb = async (req: CallServiceData): Promise<CallServiceResult> => {
                    const args = aquaArgs2Ts(req.args, argDefType);
                    // arg is function at this point
                    const result = await arg.apply(null, args);
                    return {
                        retCode: ResultCodes.success,
                        result: returnType2Aqua(result, argDefType),
                    };
                };
                serviceId = def.names.callbackSrv;
            } else {
                cb = (req: CallServiceData): CallServiceResult => {
                    const res = ts2aqua(arg, argDefType);
                    return {
                        retCode: ResultCodes.success,
                        result: res,
                    };
                };
                serviceId = def.names.getDataSrv;
            }

            // registering handlers for every argument of the function
            peer.internals.regHandler.forParticle(particle.id, serviceId, fnName, cb);
        }

        // registering handler for function response
        peer.internals.regHandler.forParticle(particle.id, def.names.responseSrv, def.names.responseFnName, (req) => {
            const userFunctionReturn = returnType2Aqua(req.args, def.arrow);

            setTimeout(() => {
                resolve(userFunctionReturn);
            }, 0);

            return {
                retCode: ResultCodes.success,
                result: {},
            };
        });

        // registering handler for injecting relay variable
        peer.internals.regHandler.forParticle(particle.id, def.names.getDataSrv, def.names.relay, (req) => {
            return {
                retCode: ResultCodes.success,
                result: peer.getStatus().relayPeerId,
            };
        });

        // registering handler for error reporting
        peer.internals.regHandler.forParticle(particle.id, def.names.errorHandlingSrv, def.names.errorFnName, (req) => {
            const [err, _] = req.args;
            setTimeout(() => {
                reject(err);
            }, 0);
            return {
                retCode: ResultCodes.success,
                result: {},
            };
        });

        peer.internals.initiateParticle(particle, (stage) => {
            // If function is void, then it's completed when one of the two conditions is met:
            //  1. The particle is sent to the network (state 'sent')
            //  2. All CallRequests are executed, e.g., all variable loading and local function calls are completed (state 'localWorkDone')
            if (isReturnTypeVoid(def) && (stage.stage === 'sent' || stage.stage === 'localWorkDone')) {
                resolve(undefined);
            }

            if (stage.stage === 'sendingError') {
                reject(`Could not send particle for ${def.functionName}: not connected  (particle id: ${particle.id})`);
            }

            if (stage.stage === 'expired') {
                reject(`Request timed out after ${particle.ttl} for ${def.functionName} (particle id: ${particle.id})`);
            }

            if (stage.stage === 'interpreterError') {
                reject(
                    `Script interpretation failed for ${def.functionName}: ${stage.errorMessage}  (particle id: ${particle.id})`,
                );
            }
        });
    });

    return promise;
}

const isReturnTypeVoid = (def: FunctionCallDef) => {
    return def.arrow.codomain.items.length == 0;
};

/**
 * Arguments could be passed in one these configurations:
 * [...actualArgs]
 * [peer, ...actualArgs]
 * [...actualArgs, config]
 * [peer, ...actualArgs, config]
 *
 * This function select the appropriate configuration and returns
 * arguments in a structured way of: { peer, config, args }
 */
const extractFunctionArgs = (
    args: any[],
    numberOfExpectedArgs: number,
): {
    peer: FluencePeer;
    config?: FnConfig;
    args: any[];
} => {
    let peer: FluencePeer;
    let structuredArgs: any[];
    let config: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
        structuredArgs = args.slice(1, numberOfExpectedArgs + 1);
        config = args[numberOfExpectedArgs + 1];
    } else {
        peer = Fluence.getPeer();
        structuredArgs = args.slice(0, numberOfExpectedArgs);
        config = args[numberOfExpectedArgs];
    }

    return {
        peer: peer,
        config: config,
        args: structuredArgs,
    };
};
