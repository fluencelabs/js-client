/**
 * Copyright 2023 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type {
  ArrowWithoutCallbacks,
  FunctionCallDef,
  JSONValue,
  ServiceDef,
  SimpleTypes,
} from "@fluencelabs/interfaces";
import { z } from "zod";

import { CallAquaFunctionConfig } from "./compilerSupport/callFunction.js";
import {
  aqua2js,
  js2aqua,
  SchemaValidationError,
  wrapJsFunction,
} from "./compilerSupport/conversions.js";
import { ServiceImpl, UserServiceImpl } from "./compilerSupport/types.js";
import { FluencePeer } from "./jsPeer/FluencePeer.js";
import { zip } from "./util/utils.js";

import { callAquaFunction, Fluence, registerService } from "./index.js";

function validateAquaConfig(
  config: unknown,
): asserts config is CallAquaFunctionConfig | undefined {
  z.union([
    z.object({
      ttl: z.number().optional(),
    }),
    z.undefined(),
  ]).parse(config);
}

// TODO: remove v5 prefix from functions

/**
 * Convenience function to support Aqua `func` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 *
 * @param args - raw arguments passed by user to the generated function
 * @param def - function definition generated by the Aqua compiler
 * @param script - air script with function execution logic generated by the Aqua compiler
 */
export const v5_callFunction = async (
  args: [
    client: FluencePeer | (JSONValue | UserServiceImpl[string]),
    ...args: (JSONValue | UserServiceImpl[string])[],
  ],
  def: FunctionCallDef,
  script: string,
): Promise<JSONValue> => {
  const [peerOrArg, ...rest] = args;

  if (!(peerOrArg instanceof FluencePeer)) {
    return await v5_callFunction(
      [getDefaultPeer(), peerOrArg, ...rest],
      def,
      script,
    );
  }

  const schemaFunctionArgs: Record<string, FunctionArg> =
    def.arrow.domain.tag === "nil" ? {} : def.arrow.domain.fields;

  const schemaFunctionArgEntries = Object.entries(schemaFunctionArgs);

  const schemaArgCount = schemaFunctionArgEntries.length;

  type FunctionArg = SimpleTypes | ArrowWithoutCallbacks;

  // if there are more args than expected in schema (schemaArgCount) then last arg is config
  const config = schemaArgCount < rest.length ? rest.pop() : undefined;

  validateAquaConfig(config);

  const callArgs = Object.fromEntries<JSONValue | ServiceImpl[string]>(
    zip(rest.slice(0, schemaArgCount), schemaFunctionArgEntries).map(
      ([arg, [argName, argType]]) => {
        if (argType.tag === "arrow") {
          if (typeof arg !== "function") {
            throw new SchemaValidationError(
              [argName],
              argType,
              "function",
              arg,
            );
          }

          return [argName, wrapJsFunction(arg, argType)];
        }

        if (typeof arg === "function") {
          throw new SchemaValidationError(
            [argName],
            argType,
            "non-function value",
            arg,
          );
        }

        return [argName, js2aqua(arg, argType, { path: [def.functionName] })];
      },
    ),
  );

  const returnTypeVoid =
    def.arrow.codomain.tag === "nil" || def.arrow.codomain.items.length === 0;

  const returnSchema =
    def.arrow.codomain.tag === "unlabeledProduct" &&
    "0" in def.arrow.codomain.items
      ? def.arrow.codomain.items[0]
      : def.arrow.codomain;

  let result = await callAquaFunction({
    script,
    peer: peerOrArg,
    args: callArgs,
    config,
  });

  if (returnTypeVoid) {
    result = null;
  }

  return aqua2js(result, returnSchema);
};

const getDefaultPeer = (): FluencePeer => {
  if (Fluence.defaultClient === undefined) {
    throw new Error(
      "Could not register Aqua service because the client is not initialized. Did you forget to call Fluence.connect()?",
    );
  }

  return Fluence.defaultClient;
};

const getDefaultServiceId = (def: ServiceDef) => {
  if (def.defaultServiceId === undefined) {
    throw new Error("Service ID is not provided");
  }

  return def.defaultServiceId;
};

type RegisterServiceType =
  | [UserServiceImpl]
  | [string, UserServiceImpl]
  | [FluencePeer, UserServiceImpl]
  | [FluencePeer, string, UserServiceImpl];

/**
 * Convenience function to support Aqua `service` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 * @param args - raw arguments passed by user to the generated function
 * @param def - service definition generated by the Aqua compiler
 */
export const v5_registerService = (
  args: RegisterServiceType,
  def: ServiceDef,
): void => {
  if (args.length === 1) {
    v5_registerService(
      [getDefaultPeer(), getDefaultServiceId(def), args[0]],
      def,
    );

    return;
  }

  if (args.length === 2) {
    if (args[0] instanceof FluencePeer) {
      v5_registerService([args[0], getDefaultServiceId(def), args[1]], def);
      return;
    }

    v5_registerService([getDefaultPeer(), args[0], args[1]], def);
    return;
  }

  const [peer, serviceId, serviceImpl] = args;

  // Schema for every function in service
  const serviceSchema = def.functions.tag === "nil" ? {} : def.functions.fields;

  // Wrapping service functions, selecting only those listed in schema, to convert their args js -> aqua and backwards
  const wrappedServiceImpl = Object.fromEntries(
    Object.entries(serviceSchema).map(([schemaKey, schemaValue]) => {
      const serviceImplValue = serviceImpl[schemaKey];

      if (serviceImplValue === undefined) {
        throw new Error(
          `Expected to have ${schemaKey} in service implementation according to schema`,
        );
      }

      return [
        schemaKey,
        wrapJsFunction(serviceImplValue.bind(serviceImpl), schemaValue),
      ] as const;
    }),
  );

  registerService({
    service: wrappedServiceImpl,
    peer,
    serviceId,
  });
};
