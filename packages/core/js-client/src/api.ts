/**
 * Copyright 2023 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type {
  FunctionCallDef,
  JSONValue,
  SimpleTypes,
  ArrowWithoutCallbacks,
  ServiceDef,
} from "@fluencelabs/interfaces";

import { CallAquaFunctionConfig } from "./compilerSupport/callFunction.js";
import {
  aqua2ts,
  ts2aqua,
  wrapFunction,
} from "./compilerSupport/conversions.js";
import { ServiceImpl } from "./compilerSupport/types.js";
import { FluencePeer } from "./jsPeer/FluencePeer.js";

import { callAquaFunction, Fluence, registerService } from "./index.js";

const isAquaConfig = (
  config: JSONValue | ServiceImpl[string] | undefined,
): config is CallAquaFunctionConfig => {
  return (
    typeof config === "object" &&
    config !== null &&
    !Array.isArray(config) &&
    ["undefined", "number"].includes(typeof config["ttl"])
  );
};

/**
 * Convenience function to support Aqua `func` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 *
 * @param args - raw arguments passed by user to the generated function
 * @param def - function definition generated by the Aqua compiler
 * @param script - air script with function execution logic generated by the Aqua compiler
 */
export const v5_callFunction = async (
  args: [
    client: FluencePeer | (JSONValue | ServiceImpl[string]),
    ...args: (JSONValue | ServiceImpl[string])[],
  ],
  def: FunctionCallDef,
  script: string,
): Promise<unknown> => {
  const [peer, ...rest] = args;

  if (!(peer instanceof FluencePeer)) {
    await v5_callFunction([getDefaultPeer(), ...rest], def, script);
    return;
  }

  const argNames = Object.keys(def.arrow);
  const schemaArgCount = argNames.length;

  type FunctionArg = SimpleTypes | ArrowWithoutCallbacks;

  const schemaFunctionArgs: Record<string, FunctionArg> =
    def.arrow.domain.tag === "nil" ? {} : def.arrow.domain.fields;

  // if args more than expected in schema (schemaArgCount) then last arg is config
  const config = schemaArgCount < rest.length ? rest.pop() : undefined;

  if (!isAquaConfig(config)) {
    throw new Error("Config should be object type");
  }

  const callArgs = Object.fromEntries<JSONValue | ServiceImpl[string]>(
    rest.slice(0, schemaArgCount).map((arg, i) => {
      const argSchema = schemaFunctionArgs[argNames[i]];

      if (argSchema.tag === "arrow") {
        if (typeof arg !== "function") {
          throw new Error("Argument and schema don't match");
        }

        const wrappedFunction = wrapFunction(arg, argSchema);

        return [argNames[i], wrappedFunction];
      }

      if (typeof arg === "function") {
        throw new Error("Argument and schema don't match");
      }

      return [argNames[i], ts2aqua(arg, argSchema)];
    }),
  );

  const returnTypeVoid =
    def.arrow.codomain.tag === "nil" || def.arrow.codomain.items.length === 0;

  const params = {
    peer,
    args: callArgs,
    config,
  };

  const result = await callAquaFunction({
    script,
    ...params,
    fireAndForget: returnTypeVoid,
  });

  const returnSchema =
    def.arrow.codomain.tag === "unlabeledProduct" &&
    def.arrow.codomain.items.length === 1
      ? def.arrow.codomain.items[0]
      : def.arrow.codomain;

  return aqua2ts(result, returnSchema);
};

const getDefaultPeer = (): FluencePeer => {
  if (Fluence.defaultClient == null) {
    throw new Error(
      "Could not register Aqua service because the client is not initialized. Did you forget to call Fluence.connect()?",
    );
  }

  return Fluence.defaultClient;
};

const getDefaultServiceId = (def: ServiceDef) => {
  if (def.defaultServiceId == null) {
    throw new Error("Service ID is not provided");
  }

  return def.defaultServiceId;
};

type RegisterServiceType =
  | [ServiceImpl]
  | [string, ServiceImpl]
  | [FluencePeer, ServiceImpl]
  | [FluencePeer, string, ServiceImpl];

/**
 * Convenience function to support Aqua `service` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 * @param args - raw arguments passed by user to the generated function
 * @param def - service definition generated by the Aqua compiler
 */
export const v5_registerService = (
  args: RegisterServiceType,
  def: ServiceDef,
): void => {
  if (args.length === 1) {
    v5_registerService(
      [getDefaultPeer(), getDefaultServiceId(def), args[0]],
      def,
    );

    return;
  } else if (args.length === 2) {
    if (args[0] instanceof FluencePeer) {
      v5_registerService([args[0], getDefaultServiceId(def), args[1]], def);
      return;
    } else {
      v5_registerService([getDefaultPeer(), args[0], args[1]], def);
      return;
    }
  }

  const [peer, serviceId, serviceImpl] = args;

  // Schema for every function in service
  const serviceSchema = def.functions.tag === "nil" ? {} : def.functions.fields;

  // Wrapping service impl to convert their args ts -> aqua and backwards
  const wrappedServiceImpl = Object.fromEntries(
    Object.entries(serviceImpl).map(([name, func]) => {
      return [name, wrapFunction(func, serviceSchema[name])];
    }),
  );

  registerService({
    service: wrappedServiceImpl,
    peer,
    serviceId,
  });
};
